"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[708],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(t),u=i,f=m["".concat(p,".").concat(u)]||m[u]||d[u]||o;return t?a.createElement(f,r(r({ref:n},c),{},{components:t})):a.createElement(f,r({ref:n},c))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},271:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const o={title:"Output types"},r=void 0,l={unversionedId:"schema/output_types",id:"schema/output_types",title:"Output types",description:"An output type Out[F[_], A] is an ast node that can take some A as input and produce a graphql value in F.",source:"@site/docs/schema/output_types.md",sourceDirName:"schema",slug:"/schema/output_types",permalink:"/gql/docs/schema/output_types",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/schema/output_types.md",tags:[],version:"current",frontMatter:{title:"Output types"},sidebar:"docs",previous:{title:"Getting started",permalink:"/gql/docs/overview/getting_started"},next:{title:"The DSL",permalink:"/gql/docs/schema/dsl"}},p={},s=[{value:"Scalar",id:"scalar",level:2},{value:"Enum",id:"enum",level:2},{value:"Field",id:"field",level:2},{value:"Type (object)",id:"type-object",level:2},{value:"Union",id:"union",level:2},{value:"Ad-hoc unions",id:"ad-hoc-unions",level:3},{value:"For the daring",id:"for-the-daring",level:3},{value:"Interface",id:"interface",level:2}],c={toc:s};function d(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"An output type ",(0,i.kt)("inlineCode",{parentName:"p"},"Out[F[_], A]")," is an ast node that can take some ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," as input and produce a graphql value in ",(0,i.kt)("inlineCode",{parentName:"p"},"F"),".\nOutput types act as continuations of their input types, such that a schema effectively is a tree of continuations.\nThe output types of gql are defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"gql.ast")," and are named after their respective GraphQL types."),(0,i.kt)("p",null,"Lets import the things we need: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import gql.ast._\nimport gql.resolver._\nimport gql.dsl._\nimport gql._\nimport cats._\nimport cats.data._\nimport cats.implicits._\n")),(0,i.kt)("h2",{id:"scalar"},"Scalar"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Scalar")," types are composed of a name and a codec\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"Scalar")," type can encode ",(0,i.kt)("inlineCode",{parentName:"p"},"A => Json")," and decode ",(0,i.kt)("inlineCode",{parentName:"p"},"Json => Either[Error, A]"),".\ngql comes with a few predefined scalars, but you can also define your own."),(0,i.kt)("p",null,"For instance, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ID")," type is defined for any ",(0,i.kt)("inlineCode",{parentName:"p"},"Scalar")," as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'final case class ID[A](value: A)\nimplicit def idScalar[F[_], A](implicit inner: Scalar[F, A]): Scalar[F, ID[A]] =\n  Scalar("ID", inner.codec.imap(ID(_))(_.value))\n  \nimplicitly[Scalar[Id, ID[String]]]\n// res0: Scalar[Id, ID[String]] = Scalar(\n//   name = "ID",\n//   codec = io.circe.Codec$$anon$4@2445e37a\n// )\n')),(0,i.kt)("h2",{id:"enum"},"Enum"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Enum")," types, like ",(0,i.kt)("inlineCode",{parentName:"p"},"Scalar")," types, are terminal types that consist of a name and non-empty bi-directional mapping from a scala type to a ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'sealed trait Color\nobject Color {\n  case object Red extends Color\n  case object Green extends Color\n  case object Blue extends Color\n}\n\nimplicit def color[F[_]] = \n  Enum(\n    "Color",\n    NonEmptyList.of(\n      "RED" -> Color.Red,\n      "GREEN" -> Color.Green,\n      "BLUE" -> Color.Blue\n    )\n  )\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Enum")," types have no constraints on the values they can encode or decode, so they can in fact, be dynamically typed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'final case class UntypedEnum(s: String)\n\nimplicit def untypedEnum[F[_]] = \n  Enum(\n    "UntypedEnum",\n    NonEmptyList.of(\n      "FIRST" -> UntypedEnum("FIRST")\n    )\n  )\n')),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Encoding a value that has not been defined in the enum will result in a GraphQL error.\nTherefore, it is recommended to enumerate the image of the enum; only use ",(0,i.kt)("inlineCode",{parentName:"p"},"sealed trait"),"s")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Enum")," types can also be constructed with the ",(0,i.kt)("inlineCode",{parentName:"p"},"dsl"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'implicit def color2[F[_]]: Enum[F, Color] = \n  enum(\n    "Color",\n    "RED" -> Color.Red,\n    "GREEN" -> Color.Green,\n    "BLUE" -> Color.Blue\n  )\n')),(0,i.kt)("h2",{id:"field"},"Field"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Field")," is a type that represents a field in a graphql ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"interface"),".\nA ",(0,i.kt)("inlineCode",{parentName:"p"},"Field[F, I, T, A]")," has arguments ",(0,i.kt)("inlineCode",{parentName:"p"},"Arg[A]"),", a continuation ",(0,i.kt)("inlineCode",{parentName:"p"},"Out[F, T]")," and a resolver that takes ",(0,i.kt)("inlineCode",{parentName:"p"},"(I, A)")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"F[T]"),".\nField also lazily captures ",(0,i.kt)("inlineCode",{parentName:"p"},"Out[F, T]"),", to allow recursive types.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"dsl")," lazily captures ",(0,i.kt)("inlineCode",{parentName:"p"},"Out[F, T]")," definitions in the implicit scope."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Check out the ",(0,i.kt)("a",{parentName:"p",href:"/gql/docs/schema/resolvers"},"resolver section")," for more info on how resolvers work.")),(0,i.kt)("h2",{id:"type-object"},"Type (object)"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Type")," is the gql equivalent of ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," in GraphQL parlance.\nA ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," consists of a name and a non-empty list of fields."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'final case class Domain(\n  name: String,\n  amount: Int\n)\n\nimplicit def domain[F[_]](implicit F: Applicative[F]): Type[F, Domain] =\n  Type[F, Domain](\n    "Domain",\n    NonEmptyList.of(\n      "name" -> Field[F, Domain, String, Unit](\n        Applicative[Arg].unit,\n        EffectResolver{ case (i, _) => F.pure(i.name.rightIor) },\n        Eval.now(stringScalar)\n      ),\n      "amount" -> Field[F, Domain, Int, Unit](\n        Applicative[Arg].unit, \n        EffectResolver{ case (i, _) => F.pure(i.amount.rightIor) },\n        Eval.now(intScalar)\n      )\n    )\n  )\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Type"),"'s look very rough, but are significantly easier to define with the ",(0,i.kt)("inlineCode",{parentName:"p"},"dsl"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'implicit def domain2[F[_]: Applicative]: Type[F, Domain] =\n  tpe(\n    "Domain",\n    "name" -> pure(_.name),\n    "amount" -> pure(_.amount)\n  )\n')),(0,i.kt)("h2",{id:"union"},"Union"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Union")," types allow unification of arbitary types.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"Union")," type defines a set of ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialFunction"),"s that can specify the the type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'sealed trait Animal\nfinal case class Dog(name: String) extends Animal\nfinal case class Cat(name: String) extends Animal\n\nimplicit def dog[F[_]: Applicative] = tpe[F, Dog]("Dog", "name" -> pure(_.name))\nimplicit def cat[F[_]: Applicative] = tpe[F, Cat]("Cat", "name" -> pure(_.name))\nimplicit def animal[F[_]: Applicative] =\n  union[F, Animal](\n    "Animal",\n    instance[Dog]{ case x: Dog => x },\n    instance[Cat]{ case x: Cat => x }\n  )\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"A curious reader might cosider the possibilty of using a total function form the unifying type to the subtypes.\nThis would also allow the scala compiler to catch non-exhaustive matches.\nThis is not possible, since the gql type needs to be available at the time of schema construction, and the specification function acts in query time.")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Defining instances for ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal")," that are not referenced in the gql type is mostly safe, since any spread will simple give no fields.\nMost GraphQL clients also handle this case gracefully, for backwards compatibility reasons.\nThe exception is ",(0,i.kt)("inlineCode",{parentName:"p"},"__typename"),".\nIf the interpreter cannot find an instance of the value when querying for ",(0,i.kt)("inlineCode",{parentName:"p"},"__typename"),", a GraphQL error will be returned.")),(0,i.kt)("h3",{id:"ad-hoc-unions"},"Ad-hoc unions"),(0,i.kt)("p",null,"In the true spirit of unification, ",(0,i.kt)("inlineCode",{parentName:"p"},"Union")," types can be constructed in a more ad-hoc fashion:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'final case class Entity1(value: String)\nfinal case class Entity2(value: String)\n\nsealed trait Unification\nobject Unification {\n  final case class E1(value: Entity1) extends Unification\n  final case class E2(value: Entity2) extends Unification\n}\n\nimplicit def entity1[F[_]: Applicative]: Type[F, Entity1] = ???\nimplicit def entity2[F[_]: Applicative]: Type[F, Entity2] = ???\nimplicit def unification[F[_]: Applicative] =\n  union[F, Unification](\n    "Unification",\n    instance[Entity1]{ case Unification.E1(value) => value },\n    instance[Entity2]{ case Unification.E2(value) => value }\n  )\n')),(0,i.kt)("h3",{id:"for-the-daring"},"For the daring"),(0,i.kt)("p",null,"Since the specify function is a ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialFunction"),", it is indeed possible to have no unifying type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def untypedUnification[F[_]: Applicative] =\n  union[F, Any](\n    "AnyUnification",\n    instance[Entity1]{ case x: Entity1 => x },\n    instance[Entity2]{ case x: Entity2 => x }\n  )\n')),(0,i.kt)("p",null,"And also complex routing logic:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'def routedUnification[F[_]: Applicative] =\n  union[F, Unification](\n    "RoutedUnification",\n    instance[Entity1]{ case Unification.E1(x) if x.value == "Jane" => x },\n    instance[Entity2]{ \n      case Unification.E1(x) => Entity2(x.value)\n      case Unification.E2(x) => x\n    },\n  )\n')),(0,i.kt)("h2",{id:"interface"},"Interface"),(0,i.kt)("p",null,"An interface is a combination of ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Union"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'sealed trait Node {\n def id: String\n}\n\nfinal case class Person(\n  name: String,\n  id: String\n) extends Node\n\nfinal case class Company(\n  name: String,\n  id: String\n) extends Node\n\nimplicit def person[F[_]: Applicative] = \n  tpe[F, Person](\n    "Person",\n    "name" -> pure(_.name),\n    "id" -> pure(x => ID(x.id))\n  )\n  \nimplicit def company[F[_]: Applicative] =\n  tpe[F, Company](\n    "Company",\n    "name" -> pure(_.name),\n    "id" -> pure(x => ID(x.id))\n  )\n  \nimplicit def node[F[_]: Applicative] =\n  interface[F, Node](\n    "Node",\n    "id" -> pure(x => ID(x.id))\n  )(\n    instance[Person]{ case x: Person => x },\n    instance[Company]{ case x: Company => x }\n  )\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In most GraphQL implementations types define the interfaces they implement,\nbut in gql the interfaces define the types that extends it.\nDefining interface implementations the other way around is ambiguous,\nsince the same type may appear two places in the schema, which raises the question of which type to use.\nAn important goal of gql is to be predictable, so such a design choice is not possible whilst maintaining predictability."),(0,i.kt)("p",{parentName:"admonition"},"Furthermore, referencing implementations this way also ensures that all types in the schema can be discovered.\nInverting the relationship cloud lead to types that are not discoverable.\nFor the curious, draw a tree of a schema where types define the interfaces they implement and consider the implications.")))}d.isMDXComponent=!0}}]);