"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[947],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,g=d["".concat(l,".").concat(u)]||d[u]||m[u]||i;return n?r.createElement(g,s(s({ref:t},p),{},{components:n})):r.createElement(g,s({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8828:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const i={title:"Extending schemas"},s=void 0,o={unversionedId:"server/schema/extending",id:"server/schema/extending",title:"Extending schemas",description:"The AST in gql is subject to extension.",source:"@site/docs/server/schema/extending.md",sourceDirName:"server/schema",slug:"/server/schema/extending",permalink:"/gql/docs/server/schema/extending",draft:!1,editUrl:"https://github.com/valdemargr/gql/tree/main/docs/server/schema/extending.md",tags:[],version:"current",frontMatter:{title:"Extending schemas"},sidebar:"docs",previous:{title:"Compiler",permalink:"/gql/docs/server/schema/compiler"},next:{title:"Planning",permalink:"/gql/docs/server/execution/planning"}},l={},c=[],p={toc:c};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The AST in gql is subject to extension.\nIn particular, the schema can be used to write arbitary information that can later be used for various purposes."),(0,a.kt)("p",null,"Integrations that use schema extensions are the ",(0,a.kt)("a",{parentName:"p",href:"../integrations/goi"},"goi")," and ",(0,a.kt)("a",{parentName:"p",href:"../integrations/relational"},"relational")," integrations."),(0,a.kt)("p",null,"Lets get some imports ready before we start."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"import gql._\nimport gql.dsl.all._\nimport gql.ast._\nimport gql.resolver._\nimport cats.effect._\nimport cats._\nimport cats.data._\nimport cats.implicits._\n")),(0,a.kt)("p",null,"For this showcase, our goal will be to add authorization to any schema."),(0,a.kt)("p",null,"To extend the schema with new attributes we must define what attribute we wish to embed into the schema.\nWe can extend a special trait based on the ast node we wish to extend."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"case class AuthorizedField(\n  permissions: List[String]\n) extends FieldAttribute[fs2.Pure]\n")),(0,a.kt)("p",null,"Lets also introduce some functions related to authorization."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"def checkPermissions(token: String, permissions: List[String]): IO[Boolean] = ???\n")),(0,a.kt)("p",null,"Now we will use our new attribute to create a dsl for out extension."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'def authed[A, B](perms: String*)(field: Field[IO, A, B]): Field[IO, A, B] = {\n  val permissions = perms.toList\n  field\n    .addAttributes(AuthorizedField(permissions))\n    .compose(Resolver.id[IO, A].arg(arg[String]("secretToken")).evalMap{ case (token, a) =>\n      checkPermissions(token, permissions).map{\n        case false => s"your token didn\'t satisfy the permissions ${permissions.mkString(", ")}".leftIor\n        case true => a.rightIor\n      }\n    }.rethrow)\n    .document(s"Requires permissions ${permissions.mkString(", ")}")\n}\n')),(0,a.kt)("p",null,"We can now use our authorization function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'case class Person(name: String, age: Int)\nimplicit lazy val person: Type[IO, Person] = tpe[IO, Person](\n  "Person",\n  "name" -> authed("read:name") {\n    lift(_.name)\n  },\n  "age" -> lift(_.name),\n  "name2" -> authed("read:name", "read:name2") {\n    authed("read:name") {\n      lift(_.age)\n    }\n  },\n)\n')),(0,a.kt)("p",null,"Now notice two things:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We forgot to add authorization to the ",(0,a.kt)("inlineCode",{parentName:"li"},"age")," field."),(0,a.kt)("li",{parentName:"ol"},"We added authorization twice to the ",(0,a.kt)("inlineCode",{parentName:"li"},"name2")," field by mistake.")),(0,a.kt)("p",null,"We will catch both of these errors by validating our schema."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},'sealed trait Error\nobject Error {\n  case class MultiplePermissionLists(field: String, perms: List[List[String]]) extends Error {\n    override def toString = \n      s"Field \'$field\' has multiple permission lists: ${perms.map(ps => s"{${ps.mkString(",")}}").mkString(", ")}"\n  }\n  case class MissingPermission(field: String) extends Error {\n    override def toString = s"Field \'$field\' is missing a permission list"\n  }\n}\n\ndef validate(schema: SchemaShape[IO, ?, ?, ?]): Chain[Error] = {\n  import SchemaShape._\n  import VisitNode._\n  val fa = schema.visitOnce[Eval, Chain[Error]]{\n    case FieldNode(name, f: Field[IO, ?, ?]) =>\n      Eval.now {\n        f.attributes.collect{ case a: AuthorizedField => a } match {\n          case Nil => Chain(Error.MissingPermission(name))\n          case a :: Nil => Chain.empty\n          case ys => Chain(Error.MultiplePermissionLists(name, ys.map(_.permissions)))\n        }\n      }\n  }\n\n  fa.value\n}\n')),(0,a.kt)("p",null,"Lets see what happens when we validate our schema."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala"},"lazy val s = SchemaShape.unit[IO](\n  fields[IO, Unit](\n    \"person\" -> lift(_ => Person(\"John\", 42))\n  )\n)\n\nvalidate(s).toList.foreach(println)\n// Field 'person' is missing a permission list\n// Field 'age' is missing a permission list\n// Field 'name2' has multiple permission lists: {read:name}, {read:name,read:name2}\n")),(0,a.kt)("p",null,"Notice that the errors we expected were caught by our validation."))}m.isMDXComponent=!0}}]);