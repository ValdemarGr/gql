"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[137],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1631:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={title:"Resolvers"},i=void 0,l={unversionedId:"schema/resolvers",id:"schema/resolvers",title:"Resolvers",description:"Resolvers are where the most interest should lie, since they act as the layer between input type and next continuation.",source:"@site/docs/schema/resolvers.md",sourceDirName:"schema",slug:"/schema/resolvers",permalink:"/gql/docs/schema/resolvers",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/schema/resolvers.md",tags:[],version:"current",frontMatter:{title:"Resolvers"},sidebar:"docs",previous:{title:"Output types",permalink:"/gql/docs/schema/output_types"},next:{title:"Context",permalink:"/gql/docs/schema/context"}},s={},p=[{value:"EffectResolver",id:"effectresolver",level:2},{value:"BatchResolver",id:"batchresolver",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Resolvers are where the most interest should lie, since they act as the layer between input type and next continuation.\nThe raw resolver types are as expressive as possible to allow as many use cases as possible, which can cause a lot of noise in the daily use of gql.\nTherefore the ",(0,r.kt)("inlineCode",{parentName:"p"},"dsl")," should be enough to get started and this section should act as an introduction for the curious."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The error types have been omitted from the resolver types for brevity.")),(0,r.kt)("h2",{id:"effectresolver"},"EffectResolver"),(0,r.kt)("p",null,"The simplest resolver is the effect resolver ",(0,r.kt)("inlineCode",{parentName:"p"},"EffectResolver[F, I, A]")," which takes ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"F[A]"),"."),(0,r.kt)("h2",{id:"batchresolver"},"BatchResolver"),(0,r.kt)("p",null,"The batch resolver ",(0,r.kt)("inlineCode",{parentName:"p"},"BatchResolver[F, I, A]")," allows the interpreter to more effeciently fetch data.\nThe resolver captures a the following steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It takes ",(0,r.kt)("inlineCode",{parentName:"li"},"I")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"F[Set[K]]")," for some ",(0,r.kt)("inlineCode",{parentName:"li"},"K")),(0,r.kt)("li",{parentName:"ul"},"Then merges the keys ",(0,r.kt)("inlineCode",{parentName:"li"},"Set[K]")," from many different resolvers into a single ",(0,r.kt)("inlineCode",{parentName:"li"},"Set[K]")),(0,r.kt)("li",{parentName:"ul"},"Then it fetches the values using a user-defined function ",(0,r.kt)("inlineCode",{parentName:"li"},"Set[K] => F[Map[K, T]]")," for some ",(0,r.kt)("inlineCode",{parentName:"li"},"T")),(0,r.kt)("li",{parentName:"ul"},"Finally it maps the values ",(0,r.kt)("inlineCode",{parentName:"li"},"Map[K, T]")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"F[A]"))),(0,r.kt)("p",null,"The types ",(0,r.kt)("inlineCode",{parentName:"p"},"K")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," are existentially quantified; they are not visible to the user.\nThe base-case implementation for ",(0,r.kt)("inlineCode",{parentName:"p"},"BatchResolver")," has ",(0,r.kt)("inlineCode",{parentName:"p"},"K = Set[I]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"T = Map[I, A]"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The resolver will automatically construct a GraphQL error if any of the keys are missing.\nTo avoid this, you must pad all missing keys.\nFor instance, you could map all values to ",(0,r.kt)("inlineCode",{parentName:"p"},"Some")," and pad all missing values with ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BatchResolver")," must also have an implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"Set[K] => F[Map[K, T]]"),", which is constructed globally."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BatchResolver")," cannot directly embed ",(0,r.kt)("inlineCode",{parentName:"p"},"Set[K] => F[Map[K, T]]"),", since this would allow ambiguity.\nWhat if two ",(0,r.kt)("inlineCode",{parentName:"p"},"BatchResolver"),"'s were to have their keys merged, what resolver's ",(0,r.kt)("inlineCode",{parentName:"p"},"Set[K] => F[Map[K, T]]")," should be used?")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"BatchResolver[F, K, T]")," is constructed as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import gql.resolver._\nimport cats.effect._\n\nval brState = BatchResolver[IO, Int, Int](keys => IO.pure(keys.map(k => k -> (k * 2)).toMap))\n// brState: cats.data.package.State[gql.SchemaState[IO], BatchResolver[IO, Set[Int], Map[Int, Int]]] = cats.data.IndexedStateT@750decd9\n")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," monad is used to keep track of the batchers that have been created and unique id generation.\nDuring schema construction, ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," can be composed using ",(0,r.kt)("inlineCode",{parentName:"p"},"Monad"),"ic operations.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema")," companion object contains smart constructors that run the ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," monad."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"contramap")," can be used to align the input and output types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import gql._\nimport gql.dsl._\nimport cats._\n\ndef statefulSchema = brState.map { (br: BatchResolver[IO, Set[Int], Map[Int, Int]]) =>\n  val adjusted: BatchResolver[IO, Int, Option[Int]] = br\n    .contramap[Int](Set(_))\n    .map { case (_, m) => m.values.headOption }\n\n  SchemaShape[IO, Unit](\n    tpe(\n      "Query",\n      "field" -> field(adjusted.contramap(_ => 42))\n    )\n  )\n}\n')),(0,r.kt)("p",null,"Which we can finally run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'import cats.effect.unsafe.implicits.global\ndef s = Schema.stateful(statefulSchema)\n                                                                                        \ndef query = """\n  query {\n    field\n  }\n"""\n                                                                                        \nimplicit def stats = Statistics[IO].unsafeRunSync()\n                                                                                        \ndef parsed = gql.parser.parse(query).toOption.get\n                                                                                        \ndef program = Execute.executor(parsed, s, Map.empty) match {\n  case Execute.ExecutorOutcome.Query(run) => run(()).map { case (_, output) => output }\n}\n                                                                                        \nprogram.unsafeRunSync()\n// res0: io.circe.JsonObject = object[field -> 84]\n')))}u.isMDXComponent=!0}}]);