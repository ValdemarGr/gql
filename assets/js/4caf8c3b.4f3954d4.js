"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[271],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,f=d["".concat(l,".").concat(u)]||d[u]||m[u]||i;return n?r.createElement(f,o(o({ref:t},p),{},{components:n})):r.createElement(f,o({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6915:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const i={title:"The DSL"},o=void 0,s={unversionedId:"schema/dsl",id:"schema/dsl",title:"The DSL",description:"The DSL consists of a set of smart constructors for the ast nodes of gql.",source:"@site/docs/schema/dsl.md",sourceDirName:"schema",slug:"/schema/dsl",permalink:"/gql/docs/schema/dsl",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/schema/dsl.md",tags:[],version:"current",frontMatter:{title:"The DSL"},sidebar:"docs",previous:{title:"Input types",permalink:"/gql/docs/schema/input_types"},next:{title:"Resolvers",permalink:"/gql/docs/schema/resolvers"}},l={},c=[{value:"Fields",id:"fields",level:2},{value:"Value resolution",id:"value-resolution",level:3},{value:"Stream and Batch resolution",id:"stream-and-batch-resolution",level:3},{value:"Structures",id:"structures",level:2},{value:"Unification instances",id:"unification-instances",level:2},{value:"Input types",id:"input-types",level:2}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The DSL consists of a set of smart constructors for the ast nodes of gql.\nThe source code for the DSL is very easy to follow and as such, the best documentation is the source code itself :-)."),(0,a.kt)("h2",{id:"fields"},"Fields"),(0,a.kt)("p",null,"The simplest form of field construction comes from the ",(0,a.kt)("inlineCode",{parentName:"p"},"field")," smart constructor.\nIt simply lifts a resolver (and optionally an argument) into a field."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},'import cats.data._\nimport cats.effect._\nimport cats.implicits._\nimport gql.dsl._\nimport gql.resolver._\n\ndef f = field(EffectResolver[IO, String, String](s => IO.pure(s.rightIor)))\n\ndef intArg = arg[Int]("intArg")\nval withArg = field(intArg)(EffectResolver[IO, (String, Int), String]{ case (s, i) => \n  IO.pure((s + i.toString()).rightIor)\n})\n')),(0,a.kt)("h3",{id:"value-resolution"},"Value resolution"),(0,a.kt)("p",null,"Wrapping every field in a ",(0,a.kt)("inlineCode",{parentName:"p"},"field")," smart constructor and then defining the resolver seperately is a bit verbose.\nThere are smart constructors for three variants of field resolvers that lift the resolver function directly to a ",(0,a.kt)("inlineCode",{parentName:"p"},"Field"),"."),(0,a.kt)("p",null,"We must decide if the field is pure, an effect or a fallible effect:"),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The effect constructor is named ",(0,a.kt)("inlineCode",{parentName:"p"},"eff")," to avoid collisions with cats-effect.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},'final case class Person(\n  name: String\n)\n\ndef t =\n  tpe[IO, Person](\n    "Person",\n    "name" -> pure(_.name),\n    "nameEffect" -> eff(x => IO.delay(x.name)),\n    "nameFallible" -> fallible { x => \n      IO.delay(Ior.both("some constructive error", x.name))\n    }\n  )\n')),(0,a.kt)("p",null,"Thereafter we must decide if any of the fields requires arguments:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},'def familyName = arg[String]("familyName")\n\ndef t2 =\n  tpe[IO, Person](\n    "Person",\n    "name" -> pure(familyName)(_ + _),\n    "nameEffect" -> eff(familyName) { case (p, fn) => IO.delay(p.name + fn) },\n    "nameFallible" -> fallible(familyName) { case (p, fn) => \n      IO.delay(Ior.both("some constructive error for $fn", p.name)) \n    }\n  )\n')),(0,a.kt)("h3",{id:"stream-and-batch-resolution"},"Stream and Batch resolution"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"StreamResolver"),"s can be constructed via the ",(0,a.kt)("inlineCode",{parentName:"p"},"stream")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"streamFallible"),' smart constructors.\nBoth smart constructors are overloaded with a variant that take an explicit "next" resolver and a variant that does not.'),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"StreamResolver")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"BatchResolver")," can be lifted into a ",(0,a.kt)("inlineCode",{parentName:"p"},"Field")," via the ",(0,a.kt)("inlineCode",{parentName:"p"},"field")," smart constructor."),(0,a.kt)("h2",{id:"structures"},"Structures"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Type"),"s, ",(0,a.kt)("inlineCode",{parentName:"p"},"Enum"),"s, ",(0,a.kt)("inlineCode",{parentName:"p"},"Interface"),"s and ",(0,a.kt)("inlineCode",{parentName:"p"},"Union"),"s are constructed via the ",(0,a.kt)("inlineCode",{parentName:"p"},"tpe"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"enum"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"interface")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"union")," smart constructors respectively.\nThe structural type smart constructors take a varargs argument structural values that are converted into non empty lists."),(0,a.kt)("h2",{id:"unification-instances"},"Unification instances"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Union"),"s and ",(0,a.kt)("inlineCode",{parentName:"p"},"Interface"),"s require implementations of their type.\nThe implementations are called ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance"),"s and consist of a ",(0,a.kt)("inlineCode",{parentName:"p"},"PartialFunction")," that goes from the unifying type to an implementing type and a gql type for the implementing type."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"instance")," smart constructor partially applies the implementing type parameter required for an ",(0,a.kt)("inlineCode",{parentName:"p"},"Instance"),", such that the scala compiler can be leveraged to infer the remaining type parameters:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},'trait Animal {\n  def sound: String\n}\n\ncase object Dog extends Animal {\n  def sound = "woof"\n}\nimplicit def dogType = tpe[IO, Dog.type]("Dog", "sound" -> pure(_.sound))\n\nval it =\n  interface[IO, Animal](\n    "Animal",\n    "sound" -> pure(_.sound)\n  )(instance[Dog.type]{ case Dog => Dog })\n')),(0,a.kt)("h2",{id:"input-types"},"Input types"),(0,a.kt)("p",null,"Review the ",(0,a.kt)("a",{parentName:"p",href:"./input_types"},"Input types")," section for more information."))}m.isMDXComponent=!0}}]);