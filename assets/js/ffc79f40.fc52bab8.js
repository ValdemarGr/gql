"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[960],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var r=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,l=function(e,n){if(null==e)return{};var t,r,l={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,l=e.mdxType,a=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=c(t),g=l,d=m["".concat(s,".").concat(g)]||m[g]||p[g]||a;return t?r.createElement(d,i(i({ref:n},u),{},{components:t})):r.createElement(d,i({ref:n},u))}));function g(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var a=t.length,i=new Array(a);i[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var c=2;c<a;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8949:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=t(7462),l=(t(7294),t(3905));const a={title:"Code generation"},i=void 0,o={unversionedId:"client/code-generation",id:"client/code-generation",title:"Code generation",description:"Writing queries in scala using the dsl is more concise and type-safe than writing out the types and codecs by hand, but still requires a lot of code for non-trivial queries.",source:"@site/docs/client/code-generation.md",sourceDirName:"client",slug:"/client/code-generation",permalink:"/gql/docs/client/code-generation",draft:!1,editUrl:"https://github.com/valdemargr/gql/tree/main/docs/client/code-generation.md",tags:[],version:"current",frontMatter:{title:"Code generation"},sidebar:"docs",previous:{title:"Query DSL",permalink:"/gql/docs/client/dsl"},next:{title:"Http4s",permalink:"/gql/docs/client/integrations/http4s"}},s={},c=[{value:"Setting up",id:"setting-up",level:2},{value:"Sbt integration",id:"sbt-integration",level:3},{value:"Usage",id:"usage",level:2}],u={toc:c};function p(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Writing queries in scala using the dsl is more concise and type-safe than writing out the types and codecs by hand, but still requires a lot of code for non-trivial queries."),(0,l.kt)("p",null,"gql also features a code generator that transforms a graphql schema file and a set of queries (or fragments) into dsl code."),(0,l.kt)("h2",{id:"setting-up"},"Setting up"),(0,l.kt)("p",null,"The code generator comes as a stand-alone cli at the maven coordinates:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'// build.sbt\n"io.github.valdemargr" %% "gql-client-codegen-cli" % "0.3.5"\n')),(0,l.kt)("p",null,"The code generator can also be integrated into sbt for a smoother development experience:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'// project/plugins.sbt\naddSbtPlugin("io.github.valdemargr" % "gql-client-codegen-sbt" % "0.3.5")\n')),(0,l.kt)("h3",{id:"sbt-integration"},"Sbt integration"),(0,l.kt)("p",null,"By default the sbt integration will look for a schema file in the resources directory at ",(0,l.kt)("inlineCode",{parentName:"p"},".../resources/schema.graphql")," and queries in the resources directory at ",(0,l.kt)("inlineCode",{parentName:"p"},".../resources/queries"),"."),(0,l.kt)("p",null,"You can, however, override or add more sources at custom locations:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'lazy val myBuild = \n    ...\n        .settings(\n            resourceGroups += Gql.resourceGroup(\n                name="other_resources",\n                schemaFile= file("path/to/schema.graphql"),\n                file("path/to/query1.graphql"),\n                file("path/to/query2.graphql")\n            )\n        )\n')),(0,l.kt)("h2",{id:"usage"},"Usage"),(0,l.kt)("p",null,"When the code-generator is invoked it will use the queries and fragments in combination with the schema to generate a set of scala files containing the equivalent query in scala code."),(0,l.kt)("p",null,"For this demonstration, the code generator will be invoked manually:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import gql.client.codegen.{ GeneratorCli => Gen }\nimport fs2.io.file.Files\nimport cats.effect._\nimport cats.implicits._\nimport cats.effect.unsafe.implicits.global\n\ndef runQuery(queryDef: String) =\n    Files[IO].tempDirectory.use{ tmp => \n        val schemaFile = tmp / "schema.graphql"\n        val queryFile = tmp / "query.graphql"\n        val sharedOutFile = tmp / "shared.scala"\n        val queryOutFile = tmp / "query.scala"\n\n        val schemaDef = """\n            enum HelloEnum {\n                HELLO,\n                WORLD\n            }\n\n            type A {\n                a: String\n            }\n\n            type B {\n                b: String\n            }\n\n            union HelloUnion = A | B\n\n            type Query {\n                helloEnum(name: String): HelloEnum,\n                helloUnion(name2: String): HelloUnion\n            }\n        """\n\n        val writeSchemaF = fs2.Stream(schemaDef)\n            .through(fs2.text.utf8.encode)\n            .through(Files[IO].writeAll(schemaFile))\n            .compile\n            .drain\n\n        val writeQueryF = fs2.Stream(queryDef)\n            .through(fs2.text.utf8.encode)\n            .through(Files[IO].writeAll(queryFile))\n            .compile\n            .drain\n\n        import io.circe._\n        import io.circe.syntax._\n        val jo = Json.obj(\n            "schema" -> Json.fromString(schemaFile.toString),\n            "shared" -> Json.fromString(sharedOutFile.toString),\n            "queries" -> Json.arr(\n                Json.obj(\n                    "query" -> Json.fromString(queryFile.toString),\n                    "output" -> Json.fromString(queryOutFile.toString)\n                )\n            )\n        )\n\n        writeSchemaF >>\n            writeQueryF >>\n            Gen.run(List("--validate", "--input",jo.spaces2)) >>\n            Files[IO].readAll(queryOutFile)\n                .through(fs2.text.utf8.decode)\n                .compile\n                .string\n                .map(println)\n    }.unsafeRunSync()\n\nrunQuery(\n    """\n        fragment HelloFragment on Query {\n            helloEnum(name: $name)\n        }\n\n        query HelloQuery($name: String) {\n            ...HelloFragment\n            helloUnion(name2: "hey") {\n                ... on A {\n                    a\n                }\n                ... on B {\n                    b\n                }\n            }\n        }\n    """\n)\n// package gql.client.generated\n// \n// import _root_.gql.client._\n// import _root_.gql.client.dsl._\n// import _root_.gql.parser.{Value => V, AnyValue, Const}\n// import cats.implicits._\n// \n// final case class HelloFragment(\n//   helloEnum: Option[HelloEnum]\n// )\n// \n// object HelloFragment {\n//   implicit val selectionSet: SelectionSet[HelloFragment] = (\n//     sel.build[Option[HelloEnum]]("helloEnum", x => x.args(arg("name", V.VariableValue("name"))))\n//   ).map(apply)\n//   \n//   implicit val fragdef: Fragment[HelloFragment] = fragment[HelloFragment]("HelloFragment", "Query")\n// }\n// \n// final case class HelloQuery(\n//   helloFragment: gql.client.generated.HelloFragment,\n//   helloUnion: Option[HelloQuery.HelloUnion]\n// )\n// \n// object HelloQuery {\n//   final case class HelloUnion(\n//     a: Option[HelloUnion.InlineA],\n//     b: Option[HelloUnion.InlineB]\n//   ) {\n//     lazy val variant: Option[HelloUnion.Variant] = \n//     (a).map(HelloUnion.Variant.OnA.apply) orElse\n//     (b).map(HelloUnion.Variant.OnB.apply)\n//   }\n//   \n//   object HelloUnion {\n//     sealed trait Variant extends Product with Serializable\n//     object Variant {\n//       final case class OnA(\n//         a: HelloUnion.InlineA\n//       ) extends Variant\n//       \n//       final case class OnB(\n//         b: HelloUnion.InlineB\n//       ) extends Variant\n//     }\n//     \n//     final case class InlineA(\n//       a: Option[String]\n//     )\n//     \n//     object InlineA {\n//       implicit val selectionSet: SelectionSet[InlineA] = (\n//         sel.build[Option[String]]("a", x => x)\n//       ).map(apply)\n//     }\n//     \n//     final case class InlineB(\n//       b: Option[String]\n//     )\n//     \n//     object InlineB {\n//       implicit val selectionSet: SelectionSet[InlineB] = (\n//         sel.build[Option[String]]("b", x => x)\n//       ).map(apply)\n//     }\n//     \n//     implicit val selectionSet: SelectionSet[HelloUnion] = (\n//       inlineFrag.build[HelloUnion.InlineA]("A", x => x),\n//       inlineFrag.build[HelloUnion.InlineB]("B", x => x)\n//     ).mapN(apply)\n//   }\n//   \n//   implicit val selectionSet: SelectionSet[HelloQuery] = (\n//     fragment.spread.build[gql.client.generated.HelloFragment](x => x).requiredFragment("HelloFragment", "Query"),\n//     sel.build[Option[HelloQuery.HelloUnion]]("helloUnion", x => x.args(arg("name2", V.StringValue("hey"))))\n//   ).mapN(apply)\n//   \n//   final case class Variables(\n//     name: Option[Option[String]] = None\n//   ) {\n//     def setName(value: Option[String]): Variables = copy(name = Some(value))\n//   }\n//   \n//   val queryExpr = (\n//     omittableVariable[Option[String]]("name")\n//   ).introduce{ _ =>\n//     selectionSet\n//   }\n//   \n//   val query = _root_.gql.client.Query.parameterized(_root_.gql.parser.QueryAst.OperationType.Query, "HelloQuery", queryExpr)\n// }\n')),(0,l.kt)("p",null,"When supplying the ",(0,l.kt)("inlineCode",{parentName:"p"},"--validate")," flag, gql will generate a stub implementation of the schema and run the same code as if running a gql server."),(0,l.kt)("p",null,"Lets construct a helper to show this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.util.{Try,Failure}\n// We will also remove the ansii color codes from the output, since they don\'t render well in the docs\ndef runFail(q: String) = \n    Try {\n        runQuery(q)\n    } match {\n        case Failure(ex) => println(ex.getMessage().replaceAll("\\u001B\\\\[[;\\\\d]*m", ""))\n    }\n')),(0,l.kt)("p",null,"Now with a parsing error:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'runFail(\n    """\n        query MyQuery {\n            test.,test\n        }\n    """\n)\n// Failed to generate code with error: failed at offset 41 on line 2 with code 46\n// char in range } to } (code 125 to 125)\n// for document:\n// | \n// |         query MyQuery {\n// |             test.,test\n// | >>>>>>>>>>>>>^^^^^^^ line:2, column:16, offset:41, character code code:46\n// |         }\n// |\n')),(0,l.kt)("p",null,"And also with a query validation error:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-scala"},'runFail(\n    """\n        query MyQuery {\n            helloEnum(name: 1)\n        }\n    """\n)\n// Failed to generate code with error: decoding failure for type `String` with message Got value \'1\' with wrong type, expecting string at root.helloEnum.name.String\n// in file /tmp/9938872561877259213/query.graphql\n// | \n// |         query MyQuery {\n// |             helloEnum(name: 1)\n// | >>>>>>>>>>>>>>>>>>>>>>>>>^^^^^^^ line:2, column:28, offset:53, character code code:49\n// |         }\n// |\n')))}p.isMDXComponent=!0}}]);